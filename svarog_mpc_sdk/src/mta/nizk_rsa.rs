//! This file is a modified version of ING bank's NIZK-RSA implementation:
//! https://github.com/ing-bank/threshold-signatures/blob/master/src/algorithms/nizk_rsa.rs
//! to support curv-kzen from v0.2.8 to v0.9.0

//!  Non interactive zero knowledge proof for Paillier and square-free N, as described in *"Efficient Noninteractive Certification
//!  of RSA Moduli and Beyond"*, chapter 3.2, [`link`](https://eprint.iacr.org/2018/057.pdf) .
//!
//!  The Paillier cryptosystem requires a modulus $`N`$ to be relatively prime to $`\phi(N)`$, which is proven in ZK by taking $`N`$th roots of several random points.

use super::{sha::HSha512Trunc256, PRIME_BIT_LENGTH_IN_PAILLIER_SCHEMA};
use curv::arithmetic::{BitManipulation, Converter, Integer, Modulo, One, Zero};
use paillier::{extract_nroot, BigInt, DecryptionKey, EncryptionKey};
use std::borrow::Borrow;
use std::convert::TryFrom;
use std::ops::Shl;
use xuanmi_base_support::*;

/// Initializes the PRNG used for random sampling of points in the algorithm
/// with the sequence of decimal digits found somewhere in Pi:
///
/// 459561513849871375704710178795731042296906667021449863746459528082436944578977
///
///
const SALT: &str = "459561513849871375704710178795731042296906667021449863746459528082436944578977";

/// Parameters are as suggested in 6.2.3 of [link](https://eprint.iacr.org/2018/987.pdf)
pub(crate) const M2: usize = 11;

/// Corresponds to $`\alpha = 6370 `$ (as in the whitepaper)
const PRIMORIAL: &str = r#"448716517440091362481155430816405474137858544178420501606558338757929148338527
6920583142497936871998688951925693423945243825110873867021729854218098254742100790101940815596194014
2468907900676141149633188172029947498666222471142795699128314649438784106402197023949268047384343715
9460067676713193884639223667035857084601354532406794210613048646099158279088960623501386338495149058
5837333952808600614537371243175674690546793523293539895122685207132377541227876337108940154492087381
3490290672436809231516731065356763193493525160238868779310055137922174496115680527519932793977258424
4792539736701036340700288635912076146492164927808919610542874218310282292669896970583856120035578253
9820254865791098393148418019329361517559492589592935910872367121263136889168946248696802202948241391
2928883488902454913524492340322599922718890878760895105937402913873414377276608236656947832307175090
5053966756235059556073636838691946836356897012383115779539949007344984067031769543244946944745455708
3936060792661024809345273981761409719703160782041772900984746513838839888786193512778538530956452564
8905444610640901769290645369888935446477559073843982605496992468605588284307311971153579731703863970
6744666668448173363193906175513548450251163502950418400936278360673701003848618208887523585202760410
0045660805633937757348591744510475798780010165968818315032044230809183597418280918429947256826068277
4683272697993855730500061223160274918361373258473553412704497335663924406111413972911417644029226449
6024171351160119689462326231540087102712961833502155639460035475610564562859396768386233113700872382
2563099450611342292284657261653863772305422216615938947561721468128287437318528356851260388775084607
2033376432252677883915884203823739988948315257311383912016966925295975180180438969999175030785077627
4588874111464869026132912020081939029798002796375097895648075022396867557270633670757584928237317246
6970244245050266781089060880709144868898520308497203519777087422325942064905545038272535516273849035
5628688943706634905982449810389530661328557381850782677221561924983234877936783136471890539395124220
9659828317788824002241566894871372271980304616245428727742177715942159072037256823157141992495888742
7166123392971366026988327340476464832745579669936690002234517103056474721054239828507880431075206385
2249740561571105640741618793118627170070315410588646442647771802031066589341358879304845579387079972
4043864342382739042396046035119257083770084671295906362572879652325763275800090184752713642376658361
8680602733120842625645142954964198838658594930025448764739522278527412056129931807094453009697007656
0461229486504018773252771360855091191876004370694539453020462096690084476681253865429278552786361828
508910022714749051734108364178374765700925133405508684883070"#;

const P: &str = "44871651744009136248115543081640547413785854417842050160655833875792914833852769205831424979368719986889519256934239452438251108738670217298542180982547421007901019408155961940142468907900676141149633188172029947498666222471142795699128314649438784106402197023949268047384343715946006767671319388463922366703585708460135453240679421061304864609915827908896062350138633849514905858373339528086006145373712431756746905467935232935398951226852071323775412278763371089401544920873813490290672436809231516731065356763193493525160238868779310055137922174496115680527519932793977258424479253973670103634070028863591207614649216492780891961054287421831028229266989697058385612003557825398202548657910983931484180193293615175594925895929359108723671212631368891689462486968022029482413912928883488902454913524492340322599922718890878760895105937402913873414377276608236656947832307175090505396675623505955607363683869194683635689701238311577953994900734498406703176954324494694474545570839360607926610248093452739817614097197031607820417729009847465138388398887861935127785385309564525648905444610640901769290645369888935446477559073843982605496992468605588284307311971153579731703863970674466666844817336319390617551354845025116350295041840093627836067370100384861820888752358520276041000456608056339377573485917445104757987800101659688183150320442308091835974182809184299472568260682774683272697993855730500061223160274918361373258473553412704497335663924406111413972911417644029226449602417135116011968946232623154008710271296183350215563946003547561056456285939676838623311370087238225630994506113422922846572616538637723054222166159389475617214681282874373185283568512603887750846072033376432252677883915884203823739988948315257311383912016966925295975180180438969999175030785077627458887411146486902613291202008193902979800279637509789564807502239686755727063367075758492823731724669702442450502667810890608807091448688985203084972035197770874223259420649055450382725355162738490355628688943706634905982449810389530661328557381850782677221561924983234877936783136471890539395124220965982831778882400224156689487137227198030461624542872774217771594215907203725682315714199249588874271661233929713660269883273404764648327455796699366900022345171030564747210542398285078804310752063852249740561571105640741618793118627170070315410588646442647771802031066589341358879304845579387079972404386434238273904239604603511925708377008467129590636257287965232576327580009018475271364237665836186806027331208426256451429549641988386585949300254487647395222785274120561299318070944530096970076560461229486504018773252771360855091191876004370694539453020462096690084476681253865429278552786361828508910022714749051734108364178374765700925133405508684883070";

/// The output size of the hash function used in the algorithm
const DIGEST_SIZE: usize = 256;

///the lower bound for the bit size of modulo N
///
/// Paillier crate generates primes with both MSB and LSB set to 1,
/// hence lower bound of the product of primes  is $` (2^{(prime\_size-1)} + 1)^2 `$ ,  where small terms can be ignored
/// so that resulting bit size is in $`[( 2 * prime\_size -1 ).. (2 * prime\_size) ] `$
pub(crate) const N_MIN_SIZE: usize = 2 * PRIME_BIT_LENGTH_IN_PAILLIER_SCHEMA - 1;

/// generates the vector of $` \rho_{i} `$ of size M2
///
/// implements rejection sampling algorithm for $`\rho`$ as described in the [whitepaper](https://eprint.iacr.org/2018/057.pdf) , section C.4
pub fn get_rho_vec(n: &BigInt) -> Vec<BigInt> {
    let key_length = n.bit_length();
    let salt = BigInt::from_str_radix(SALT, 10).expect("not a decimal number");

    (0..M2 as u64)
        .map(|i| {
            (1u64..1000) // this upper limit should be never hit normally, unless gen_mask() is changed to return numbers too big
                .map(|j| {
                    let s = hash(&[&n, &salt, &BigInt::from(i), &BigInt::from(j)]);
                    gen_mask(key_length, &s) % n
                })
                .find(|rho| rho < n)
                .expect("cant find rho")
        })
        .collect::<Vec<_>>()
}

/// generates non-interactive proof of correctness of public Paillier key
pub fn gen_proof(dk: &DecryptionKey) -> Vec<BigInt> {
    let n = dk.q.borrow() * dk.p.borrow();

    let result = get_rho_vec(&n)
        .into_iter()
        .map(|rho| extract_nroot(&dk, &rho))
        .collect();
    result
}

/// Verifies non-interactive proof of correctness of public Paillier key.
/// Checks also whether given public key has expected bit size
pub fn verify(encryption: &EncryptionKey, sigmas: &[BigInt]) -> Outcome<()> {
    assert_throw!(sigmas.len() == M2, "NIZKError.WrongProofSize");

    let n = &encryption.n;
    let bit_length_of_n = n.bit_length();

    assert_throw!(
        bit_length_of_n >= N_MIN_SIZE,
        &format!("NIZKError.WrongSizeOfN {}", bit_length_of_n)
    );

    let rho_correct = sigmas
        .iter()
        .zip(get_rho_vec(n).into_iter())
        .all(|(sigma, rho)| rho == BigInt::mod_pow(&sigma, &n, &n));
    assert_throw!(rho_correct, "NIZKError.IncorrectRho");
    check_divisibility(&n).catch_()?;
    Ok(())
}

pub fn check_divisibility(n: &BigInt) -> Outcome<()> {
    // let alpha_primorial = str::parse::<BigInt>(&PRIMORIAL).unwrap();
    // let primorial: &str = PRIMORIAL;
    // let alpha_primorial = BigInt::from_str_radix(primorial, 10u8).unwrap();
    let alpha_primorial = BigInt::from_str_radix(P, 10u8).unwrap();
    let gcd_test = alpha_primorial.gcd(&n);
    assert_throw!(gcd_test != BigInt::one(), "NIZKError.FailedProof");
    Ok(())
}
/// produces the hash value of the concatenation of `BigInt` numbers
fn hash(bigints: &[&BigInt]) -> BigInt {
    HSha512Trunc256::create_hash(bigints)
}

/// Mask generation function, as described in [rfc8017](https://tools.ietf.org/html/rfc8017/#appendix-B.2.1), section B.2.1
///
/// For counter from 0 to $` \lceil \frac{mask\_length}{DIGEST\_SIZE} \rceil - 1`$, and output T as empty string, do T = T || Hash(seed || counter)
///
/// Note that $` \lceil \frac{mask\_length}{DIGEST\_SIZE} \rceil - 1 = \lfloor \frac{mask\_length-1}{DIGEST\_SIZE} \rfloor `$
fn gen_mask(mask_length: usize, seed: &BigInt) -> BigInt {
    let counter =
        u64::try_from((mask_length - 1) / DIGEST_SIZE).expect("gen_mask: parameters too large");

    (0..=counter)
        .map(|i| hash(&[&seed, &BigInt::from(i)]))
        .fold(BigInt::zero(), |acc, v| acc.shl(DIGEST_SIZE) + v)
}

#[cfg(test)]
mod tests {
    use paillier::KeyGeneration;
    use paillier::Paillier;

    use super::*;
    use crate::mta::PRIME_BIT_LENGTH_IN_PAILLIER_SCHEMA;

    #[test]
    fn test_correct_zk_proof() -> Outcome<()> {
        let (encryption, decryption) =
            Paillier::keypair_with_modulus_size(2 * PRIME_BIT_LENGTH_IN_PAILLIER_SCHEMA).keys();
        for _ in 0..=10 {
            let proof = gen_proof(&decryption);
            verify(&encryption, &proof).catch_()?;
        }
        Ok(())
    }

    #[test]
    #[ignore]
    fn test_key_size() {
        for _ in 0..10 {
            let (encryption, _) =
                Paillier::keypair_with_modulus_size(2 * PRIME_BIT_LENGTH_IN_PAILLIER_SCHEMA).keys();
            let x = encryption.n.bit_length();
            assert!(x >= N_MIN_SIZE);
        }
    }
}
